import os
import time

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import torch
import torch.nn as nn
from torch.utils.data import TensorDataset, DataLoader

from tqdm.notebook import tqdm as tqdm_notebook
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler

df = pd.read_csv(r"C:\Users\infos\Downloads\household_power_consumption_household_power_consumption.csv")

df.head()
df.shape

global_active_power = df.pop('Global_active_power')
global_reactive_power = df.pop('Global_reactive_power')
df['Global_active_power'] = global_active_power
df['Global_reactive_power'] = global_reactive_power

df.infer_objects().dtypes

df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)
df['DateTime'] = pd.to_datetime(df['Date'].dt.strftime('%Y-%m-%d') + ' ' + df['Time'])

df.set_index('DateTime', inplace=True)

df.drop(['Date', 'Time'], axis=1, inplace=True)

for i in range(len(df.columns)):
    try:
        df[df.columns[i]] = pd.to_numeric(df[df.columns[i]], errors='coerce')
        print(f"Converted column {i} to numeric")
    except Exception as e:
        print(f"Could not convert column {i}: {e}")
        
df.shape

df.infer_objects().dtypes

df_default = df[1::60]

df_default.head()

tempV = df_default['Voltage']
tempV.plot()

tempG = df_default['Global_intensity']
tempG.plot()

tempP = df_default['Global_active_power']
tempP.plot()

tempS = df_default['Sub_metering_1']
tempS.plot()

tempS2 = df_default['Sub_metering_2']
tempS.plot()

tempS3 = df_default['Sub_metering_3']
tempS.plot()

df_group_1 = df_default[df_default['Sub_metering_1'] != 0][['Voltage',	'Global_intensity',	'Sub_metering_1', 'Global_active_power','Global_reactive_power']]
df_group_2 = df_default[df_default['Sub_metering_2'] != 0][['Voltage',	'Global_intensity',	'Sub_metering_2', 'Global_active_power','Global_reactive_power']]
df_group_3 = df_default[df_default['Sub_metering_3'] != 0][['Voltage',	'Global_intensity',	'Sub_metering_3', 'Global_active_power','Global_reactive_power',]]

df_group_3.describe()

df_group_3.plot(kind='scatter', x='Sub_metering_3', y='Global_active_power', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

df_group_3['Voltage'].plot(kind='hist', bins=20, title='Voltage')
plt.gca().spines[['top', 'right',]].set_visible(False)

df_group_3['Global_active_power'].plot(kind='hist', bins=20, title='Voltage')
plt.gca().spines[['top', 'right',]].set_visible(False)

df_group_3.plot(figsize=(7,6))

# Create interaction features
df_default['Kitchen_laundry_interaction'] = df_default['Sub_metering_1'] * df_default['Sub_metering_2']

# Handle missing values
df_default.fillna(df.mean(), inplace=True)

# Scale numerical features
scaler = StandardScaler()
numerical_cols = ['Global_active_power', 'Global_reactive_power', 'Voltage', 'Global_intensity', 'Sub_metering_1', 'Sub_metering_2', 'Sub_metering_3']
df_default[numerical_cols] = scaler.fit_transform(df_default[numerical_cols])


from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Example ARIMA model with refined parameters
p = 2
d = 1
q = 2

model = ARIMA(train_data['Global_active_power'], order=(p, d, q))
model_fit = model.fit()

# Forecasting
forecast = model_fit.forecast(steps=len(test_data))

# Evaluate forecast
mae = mean_absolute_error(test_data['Global_active_power'], forecast)
rmse = mean_squared_error(test_data['Global_active_power'], forecast, squared=False)

print(f"Mean Absolute Error (MAE): {mae}")
print(f"Root Mean Squared Error (RMSE): {rmse}")

# Mean Absolute Error (MAE): 0.660993235192145
# Root Mean Squared Error (RMSE): 0.8230344928093126

from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Example ARIMA model with achieved parameters
p = 2
d = 0
q = 1

model = ARIMA(train_data['Global_active_power'], order=(p, d, q))
model_fit = model.fit()

# Forecasting
forecast = model_fit.forecast(steps=len(test_data))

# Evaluate forecast
mae = mean_absolute_error(test_data['Global_active_power'], forecast)
rmse = mean_squared_error(test_data['Global_active_power'], forecast, squared=False)

print(f"Mean Absolute Error (MAE): {mae}")
print(f"Root Mean Squared Error (RMSE): {rmse}")

# Mean Absolute Error (MAE): 0.7322669716093775
# Root Mean Squared Error (RMSE): 0.8787087792479928
